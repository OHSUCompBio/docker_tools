'''
Created on Aug. 24, 2022

@author: pleyte
'''

import argparse
from enum import Enum
import logging

from edu.ohsu.compbio.txeff.util.refseq_to_ccds import RefseqToCcds
from edu.ohsu.compbio.txeff.util.tfx_log_config import TfxLogConfig
from edu.ohsu.compbio.txeff.util.tx_eff_csv import TxEffCsv
from edu.ohsu.compbio.txeff.variant_transcript import VariantTranscript


class CcdsMapFileType(Enum):
    '''
    File type that maps Refseq to CCDS
    '''
    GFF = 1
    CSV = 2
    
class TxEffCcds(object):
    '''
    This class adds CCDS accessions to the transcript effects 
    '''
    def __init__(self, refseq_to_ccds_file):
        '''
        refseq_to_ccds_file is the path to a file that contains mappings from RefSeq id to CCDS id. The file can either 
        be the NCBI GFF (eg https://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/annotation/GRCh37_latest/refseq_identifiers/GRCh37_latest_genomic.gff.gz) 
        or the csv file generated by ``tx_eff_csv.py``  
        '''
        # Save the filename for later 
        self.refseq_to_ccds_file = refseq_to_ccds_file
        
        # Set up a logger for this class
        self.logger = logging.getLogger(__name__)

    def _get_refseq_to_ccds_mappings(self):
        '''
        Return a dictionary of RefSeq id to CCDS id. The mappings are read from a CSV or a GFF that was specified at class construction.
        '''
        refseq_to_ccds = RefseqToCcds()
        
        map_file_type = self.__get_file_type(self.refseq_to_ccds_file)
        
        if(map_file_type == CcdsMapFileType.GFF):
            refSeq_to_ccds_mappings = refseq_to_ccds.get_mappings_from_gff(self.refseq_to_ccds_file)
        elif(map_file_type == CcdsMapFileType.CSV):
            refSeq_to_ccds_mappings = refseq_to_ccds.get_mappings_from_csv(self.refseq_to_ccds_file)
        else:
            raise Exception(f"Mapping file must be csv or gff. File type is unknown: {self.refseq_to_ccds_file}")
        
        return refSeq_to_ccds_mappings

    def __get_file_type(self, file_name:str):        
        '''
        Determines file type by reading the first line of the file. A gff file will have a comment with the gff version in the first line; a csv will have the field headers in the first line. 
        '''
        with open(file_name) as f:
            firstline = f.readline().rstrip()
        
        if('gff' in firstline):
            # The first line of a gff file should be something like "##gff-version 3" 
            return CcdsMapFileType.GFF
        elif('refseq_id' in firstline and 'ccds_id' in firstline):
            # The first line of the csv is the field list
            return CcdsMapFileType.CSV
            
        self.logger.warn(f"Expected GFF or CSV but received unknown file type having first line: {firstline}")
        return None

    def _get_preferred_refseq_transcript(self, transcript0: VariantTranscript, transcript1: VariantTranscript):
        '''
        When a CCDS transcript is mapped to multiple RefSeq transcripts then we need to choose just one RefSeq. The one
        we choose is the earliest because it is assumed to be the best curated.  So NM_111.5 is preferred over
        'NM_222.4'.  
        ''' 
        if(not transcript0.refseq_transcript.startswith('NM_') or not transcript1.refseq_transcript.startswith('NM_')):
            raise ValueError(f'Both transcripts should have a RefSeq accession starting with "NM_": {transcript0.refseq_transcript}, {transcript1.refseq_transcript}')
        
        # If the the transcripts are the same then it doesn't matter which one is returned 
        if transcript0.refseq_transcript == transcript1.refseq_transcript:
            return transcript0
        
        t0_accession, t0_version = map(int, transcript0.refseq_transcript.replace('NM_', '').split('.'))
        t1_accession, t1_version = map(int, transcript1.refseq_transcript.replace('NM_', '').split('.'))

        if(t0_accession == t1_accession):
            if(t0_version > t1_version):
                return transcript0
            else:
                return transcript1
        elif(t0_accession < t1_accession):
            return transcript0
        else:
            return transcript1

    def _get_ccds_mapped_transcripts(self, refseq_transcripts: list):
        '''
        Return a map where the key is a CCDS accession and the value is a VariantTranscript whose 'refseq_transcript'
        is the RefSeq accession that is mapped to the CCDS key. Any transcripts in the 'refseq_transcripts' parameter
        that cannot be mapped to a CCDS accession will not be in the returned map.
        '''
        # Load the refseq to CCDS map from file        
        refseq_to_ccds_mappings = self._get_refseq_to_ccds_mappings()        
        if(len(refseq_to_ccds_mappings) == 0): 
            raise Exception(f"No mappings found in input file {self.refseq_to_ccds_file}") 

        ccds_to_transcript = {}
        cnt_mapped_to_ccds = 0
        cnt_not_mapped_to_ccds = 0 

        for variant_transcript in refseq_transcripts:
            refseq_id = variant_transcript.refseq_transcript
            ccds_id = refseq_to_ccds_mappings.get(refseq_id)
            
            if ccds_id:
                cnt_mapped_to_ccds = cnt_mapped_to_ccds + 1
                existing_transcript = ccds_to_transcript.get(ccds_id)
                if existing_transcript:
                    # A refseq accession has already been mapped to this ccds but there can only be one, so make a choice.
                    preferred_transcript = self._get_preferred_refseq_transcript(variant_transcript, existing_transcript)
                    ccds_to_transcript[ccds_id] = preferred_transcript
                    self.logger.debug(f'RefSeq {variant_transcript.refseq_transcript} and {existing_transcript.refseq_transcript} both map to {ccds_id}. {preferred_transcript.refseq_transcript} is preferred.')
                else:
                    # Put the new mapping in the dictionary 
                    ccds_to_transcript[ccds_id] = variant_transcript
            else:
                cnt_not_mapped_to_ccds = cnt_not_mapped_to_ccds + 1
                self.logger.debug(f"Unable to find CCDS id mapping for {refseq_id}")

        self.logger.info(f"Mapped {cnt_mapped_to_ccds} RefSeq accessions to CCDS.")
        if(cnt_not_mapped_to_ccds > 0):
            self.logger.info(f"Could not find mappings for {cnt_not_mapped_to_ccds} refseq ids.")

        return ccds_to_transcript
    
    def _get_ccds_transcripts(self, refseq_transcripts: list):
        '''
        Take a list of variant transcripts that have refseq accessions and see if any of them are mapped to 
        CCDS accessions. For every variant-transcript whose refseq can be mapped to ccds, create a copy of it, 
        and change the transcript identifier to the ccds accession. 
        '''
        ccds_transcripts = []
        
        # Get a map of refseq transcripts that can be mapped to a ccds accession 
        ccds_to_transcript = self._get_ccds_mapped_transcripts(refseq_transcripts)
        
        # For each transcript make a copy and substitute the refseq accession with the ccds 
        for ccds_id, refseq_transcript in ccds_to_transcript.items():
            ccds_transcript = refseq_transcript.get_copy()
            ccds_transcript.refseq_transcript = ccds_id
            ccds_transcripts.append(ccds_transcript)
        
        return ccds_transcripts

    def add_ccds_transcripts(self, refseq_transcripts: list):
        '''
        Iterate over the list of RefSeq transcripts, lookup each refseq id in the Refseq-to-CCDS id map, and create a copy of the transcript.  
        '''
        # Create copies of every refseq transcript that has an accession that is mapped to a CCDS accession. 
        ccds_transcripts = self._get_ccds_transcripts(refseq_transcripts)
        
        # Add the CCDS transcripts to the list
        refseq_transcripts.extend(ccds_transcripts)
        
        return refseq_transcripts

def _parse_args():
    '''
    Validate and return command line arguments.
    '''
    parser = argparse.ArgumentParser(description='Read file generated by tx_eff_hgvs.py and create a copy of each RefSeq transcript, with its corresponding CCDS id.')

    parser.add_argument('-i', '--in_file',  
                        help='Input CSV (generated by tx_eff_hgvs.py)',
                        type=argparse.FileType('r'),
                        required=True)
    
    parser.add_argument('-c', '--ccds_map', 
                        help='Input CSV or GFF with Annovar-to-CCDS mappings. Use refseq_to_ccds.py to convert GFF to CSV.', 
                        type=argparse.FileType('r'), 
                        required=True)

    parser.add_argument('-o', '--out_file', 
                        help='Output CSV', 
                        type=argparse.FileType('w'), 
                        required=True)
    
    args = parser.parse_args()
    return args

def _main():
    '''
    '''
    logging.config.dictConfig(TfxLogConfig().log_config)
    
    args = _parse_args()
    
    # Read transcripts that have been written to csv
    tx_eff_csv = TxEffCsv()
    transcripts = tx_eff_csv.read_transcripts(args.in_file.name)
    
    # Add CCDS copies of refseq transcripts
    tx_eff_ccds = TxEffCcds(args.ccds_map.name)
    tx_eff_ccds.add_ccds_transcripts(transcripts)
    
    # Write the old and new records to file
    tx_eff_csv.write_transcripts(args.out_file.name, transcripts)
    
if __name__ == '__main__':
    _main()        